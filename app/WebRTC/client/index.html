<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>WebRTC MVP</title>
		<style>
			body {
				font-family: sans-serif;
				margin: 24px;
			}
			.layout {
				display: grid;
				grid-template-columns: 1fr 240px;
				gap: 16px;
			}
			#videos {
				display: grid;
				gap: 12px;
				grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
			}
			#participants {
				border: 1px solid #ddd;
				border-radius: 8px;
				padding: 12px;
				height: fit-content;
			}
			.participant {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 6px 0;
				border-bottom: 1px solid #eee;
			}
			.participant:last-child {
				border-bottom: none;
			}
			.badge {
				font-size: 12px;
				padding: 2px 6px;
				border-radius: 999px;
				background: #eee;
			}
			.badge.on {
				background: #c9f7d4;
			}
			.badge.off {
				background: #f7c9c9;
			}
			.badge.speaking {
				background: #ffe4a3;
			}
			@media (max-width: 960px) {
				.layout {
					grid-template-columns: 1fr;
				}
			}
			video {
				width: 100%;
				background: #111;
			}
			.controls {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				margin-bottom: 16px;
			}
			
			/* Authorization UI */
			.auth-status {
				margin-bottom: 16px;
				padding: 12px;
				border-radius: 6px;
				display: none;
			}
			.auth-status.show {
				display: block;
			}
			.auth-status.loading {
				background: #e3f2fd;
				border: 1px solid #2196f3;
				color: #1976d2;
			}
			.auth-status.error {
				background: #ffebee;
				border: 1px solid #f44336;
				color: #d32f2f;
			}
			.auth-loading-spinner {
				display: inline-block;
				width: 16px;
				height: 16px;
				border: 2px solid currentColor;
				border-radius: 50%;
				border-top-color: transparent;
				animation: spin 0.8s linear infinite;
				margin-right: 8px;
				vertical-align: middle;
			}
			@keyframes spin {
				to { transform: rotate(360deg); }
			}
		</style>
	</head>
	<body>
		<div id="authStatus" class="auth-status">
			<div id="authStatusText"></div>
		</div>
		<div class="controls">
			<input id="userId" placeholder="User ID" />
			<input id="sessionId" placeholder="Session ID" />
			<button id="connect">Connect</button>
			<button id="share">Share screen</button>
			<button id="stopShare">Stop share</button>
			<button id="toggleAudio">Mute audio</button>
			<button id="toggleVideo">Stop video</button>
		</div>
		<div class="layout">
			<div id="videos"></div>
			<div id="participants"></div>
		</div>

		<script type="module">
			import { WebRTCClient } from "./webrtc-client-framework-ready.js";

			const videos = document.getElementById("videos");
			const connectButton = document.getElementById("connect");
			const shareButton = document.getElementById("share");
			const stopShareButton = document.getElementById("stopShare");
			const toggleAudioButton = document.getElementById("toggleAudio");
			const toggleVideoButton = document.getElementById("toggleVideo");
			const participants = document.getElementById("participants");
			let client = null;
			let audioEnabled = true;
			let videoEnabled = true;
			const participantMap = new Map();

			function peerIdFromStream(streamId) {
				const parts = String(streamId || "").split(":");
				return parts.length > 1 ? parts[0] : streamId;
			}

			function addVideo(track, stream) {
				const peerId = peerIdFromStream(stream.id);
				const elementId = `${stream.id}-${track.kind}-${track.id}`;
				let element = document.getElementById(elementId);
				if (!element) {
					element = document.createElement(track.kind === "audio" ? "audio" : "video");
					element.id = elementId;
					element.dataset.peerId = peerId;
					element.dataset.kind = track.kind;
					element.dataset.streamId = stream.id;
					const screenStreamId = client?.peerScreenStreams?.get(peerId);
					element.dataset.source = screenStreamId && screenStreamId === stream.id ? "screen" : "camera";
					element.autoplay = true;
					element.playsInline = true;
					element.srcObject = stream;
					videos.appendChild(element);
				}

				track.onended = () => {
					if (element && element.parentNode) {
						element.parentNode.removeChild(element);
					}
				};

				stream.onremovetrack = (event) => {
					if (event.track !== track) {
						return;
					}
					if (element && element.parentNode) {
						element.parentNode.removeChild(element);
					}
				};
			}

			function removePeer(peerId) {
				const nodes = Array.from(videos.querySelectorAll(`[data-peer-id="${peerId}"]`));
				nodes.forEach((node) => node.remove());
				participantMap.delete(peerId);
				renderParticipants();
			}

			function renderParticipants() {
				participants.innerHTML = "";
				for (const participant of participantMap.values()) {
					const row = document.createElement("div");
					row.className = "participant";
					const name = document.createElement("div");
					name.textContent = participant.userId || participant.peerId;
					const badges = document.createElement("div");
					const audioBadge = document.createElement("span");
					audioBadge.className = `badge ${participant.audioEnabled ? "on" : "off"}`;
					audioBadge.textContent = participant.audioEnabled ? "audio" : "muted";
					const videoBadge = document.createElement("span");
					videoBadge.className = `badge ${participant.videoEnabled ? "on" : "off"}`;
					videoBadge.textContent = participant.videoEnabled ? "video" : "no video";
					const speakingBadge = document.createElement("span");
					speakingBadge.className = `badge ${participant.speaking ? "speaking" : ""}`;
					speakingBadge.textContent = participant.speaking ? "speaking" : "";
					badges.appendChild(audioBadge);
					badges.appendChild(videoBadge);
					if (participant.speaking) {
						badges.appendChild(speakingBadge);
					}
					row.appendChild(name);
					row.appendChild(badges);
					participants.appendChild(row);
				}
			}

			function upsertParticipant(info) {
				participantMap.set(info.peerId, {
					peerId: info.peerId,
					userId: info.userId,
					audioEnabled: info.audioEnabled ?? true,
					videoEnabled: info.videoEnabled ?? true,
					screenEnabled: info.screenEnabled ?? false,
					speaking: info.speaking ?? false,
				});
				renderParticipants();
			}

			function updateMediaState(info) {
				console.log("updateMediaState received:", info);
				const participant = participantMap.get(info.peerId);
				if (!participant) {
					console.log("Participant not found, creating:", info.peerId);
					upsertParticipant(info);
					return;
				}
				
				// Track what changed
				let changed = false;
				
				if (typeof info.audioEnabled !== "undefined" && participant.audioEnabled !== info.audioEnabled) {
					console.log(`[${info.peerId}] Audio changed: ${participant.audioEnabled} -> ${info.audioEnabled}`);
					participant.audioEnabled = info.audioEnabled;
					changed = true;
				}
				
				if (typeof info.videoEnabled !== "undefined" && participant.videoEnabled !== info.videoEnabled) {
					console.log(`[${info.peerId}] Video changed: ${participant.videoEnabled} -> ${info.videoEnabled}`);
					participant.videoEnabled = info.videoEnabled;
					changed = true;
					
					// When video is disabled, remove ALL video tiles for this peer except screen share
					if (info.videoEnabled === false) {
						console.log(`[${info.peerId}] Removing camera video tiles...`);
						// Remove by data-peer-id and data-kind, but keep screen shares
						const allVideos = Array.from(videos.querySelectorAll('[data-kind="video"]'));
						const toRemove = allVideos.filter(el => {
							const isPeerId = el.dataset.peerId === info.peerId;
							const isNotScreen = el.dataset.source !== "screen";
							const isCamera = !el.dataset.source || el.dataset.source === "camera";
							return isPeerId && (isNotScreen || isCamera);
						});
						console.log(`[${info.peerId}] Found ${toRemove.length} camera tiles to remove`);
						toRemove.forEach(el => {
							console.log(`Removing: ${el.id}`);
							el.remove();
						});
					}
				}
				
				if (typeof info.screenEnabled !== "undefined" && participant.screenEnabled !== info.screenEnabled) {
					console.log(`[${info.peerId}] Screen changed: ${participant.screenEnabled} -> ${info.screenEnabled}`);
					participant.screenEnabled = info.screenEnabled;
					changed = true;
					
					// When screen is disabled, remove screen share video tiles 
					if (info.screenEnabled === false) {
						console.log(`[${info.peerId}] Removing screen video tiles...`);
						const allVideos = Array.from(videos.querySelectorAll('[data-kind="video"]'));
						const toRemove = allVideos.filter(el => {
							return el.dataset.peerId === info.peerId && el.dataset.source === "screen";
						});
						console.log(`[${info.peerId}] Found ${toRemove.length} screen tiles to remove`);
						toRemove.forEach(el => {
							console.log(`Removing: ${el.id}`);
							el.remove();
						});
					}
				}
				
				if (changed) {
					console.log(`[${info.peerId}] Updated, re-rendering participants`);
					renderParticipants();
				}
			}

			function updateSpeaking(info) {
				const participant = participantMap.get(info.peerId);
				if (!participant) {
					upsertParticipant(info);
					return;
				}
				participant.speaking = info.speaking;
				renderParticipants();
			}

			function handleScreenStream(info) {
				if (info.screenEnabled && info.screenStreamId) {
					const nodes = Array.from(videos.querySelectorAll(`[data-peer-id="${info.peerId}"][data-kind="video"][data-stream-id="${info.screenStreamId}"]`));
					nodes.forEach((node) => {
						node.dataset.source = "screen";
					});
					return;
				}
				if (info.screenEnabled === false) {
					const bySource = Array.from(videos.querySelectorAll(`[data-peer-id="${info.peerId}"][data-kind="video"][data-source="screen"]`));
					bySource.forEach((node) => node.remove());
					if (info.screenStreamId) {
						const byStream = Array.from(videos.querySelectorAll(`[data-peer-id="${info.peerId}"][data-kind="video"][data-stream-id="${info.screenStreamId}"]`));
						byStream.forEach((node) => node.remove());
					}
				}
			}

			function handleTrackRemoved(info) {
				if (!info.streamId) {
					return;
				}
				const nodes = Array.from(videos.querySelectorAll(`[data-stream-id="${info.streamId}"]`));
				nodes.forEach((node) => node.remove());
			}

			function showAuthorizationStatus(message, isError = false) {
				const statusDiv = document.getElementById("authStatus");
				const statusText = document.getElementById("authStatusText");
				statusDiv.classList.add("show");
				
				if (isError) {
					statusDiv.classList.remove("loading");
					statusDiv.classList.add("error");
					statusText.textContent = `‚ùå ${message}`;
				} else {
					statusDiv.classList.remove("error");
					statusDiv.classList.add("loading");
					statusText.innerHTML = `<span class="auth-loading-spinner"></span>Authorizing...`;
				}
			}

			function hideAuthorizationStatus() {
				const statusDiv = document.getElementById("authStatus");
				statusDiv.classList.remove("show");
				statusDiv.classList.remove("loading");
				statusDiv.classList.remove("error");
			}

			connectButton.addEventListener("click", async () => {
				const userId = document.getElementById("userId").value || "user-1";
				const sessionId = document.getElementById("sessionId").value || "session-1";
				client = new WebRTCClient({
					url: `ws://${location.host}/ws`,
					userId,
					sessionId,
				});
				
				// Agregar listeners de eventos
				client.addEventListener("track", (event) => {
					const { track, streams } = event.detail;
					if (streams.length > 0) {
						addVideo(track, streams[0]);
					}
				});
				
				client.addEventListener("peer-left", (event) => {
					removePeer(event.detail.peerId);
				});
				
				client.addEventListener("peer-joined", (event) => {
					upsertParticipant(event.detail);
				});
				
				client.addEventListener("media-state", (event) => {
					updateMediaState(event.detail);
				});
				
				client.addEventListener("speaking", (event) => {
					updateSpeaking({
						peerId: event.detail.peerId,
						speaking: event.detail.speaking,
					});
				});
				
				client.addEventListener("screen-stream", (event) => {
					handleScreenStream({
						peerId: event.detail.peerId,
						screenEnabled: event.detail.enabled,
						screenStreamId: event.detail.streamId,
					});
				});
				
			client.addEventListener("peer-list", (event) => {
				const peers = event.detail.peers || [];
				peers.forEach((peer) => upsertParticipant(peer));
			});
			
			client.addEventListener("connected", () => {
				hideAuthorizationStatus();
				});
				
				client.addEventListener("connection-error", (event) => {
					showAuthorizationStatus(`Connection failed: ${event.detail.error.message}`, true);
				});
				
				try {
					await client.connect();
				} catch (error) {
					showAuthorizationStatus(`Connection failed: ${error.message}`, true);
				}
			});

			toggleAudioButton.addEventListener("click", async () => {
				if (!client) {
					return;
				}
				audioEnabled = !audioEnabled;
				await client.toggleAudio(audioEnabled);
				toggleAudioButton.textContent = audioEnabled ? "Mute audio" : "Unmute audio";
			});

			toggleVideoButton.addEventListener("click", async () => {
				if (!client) {
					return;
				}
				videoEnabled = !videoEnabled;
				await client.toggleVideo(videoEnabled);
				toggleVideoButton.textContent = videoEnabled ? "Stop video" : "Start video";
			});

			shareButton.addEventListener("click", async () => {
				if (client) {
					await client.startScreenShare();
				}
			});

			stopShareButton.addEventListener("click", async () => {
				if (client) {
					await client.stopScreenShare();
				}
			});
		</script>
	</body>
</html>
